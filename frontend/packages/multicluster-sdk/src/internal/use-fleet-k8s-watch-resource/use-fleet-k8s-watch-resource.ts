/* Copyright Contributors to the Open Cluster Management project */
import {
  consoleFetchJSON,
  K8sResourceCommon,
  useK8sModel,
  useK8sWatchResource,
  WatchK8sResult,
} from '@openshift-console/dynamic-plugin-sdk'
import { useEffect, useMemo, useState } from 'react'

import { FleetK8sResourceCommon, FleetWatchK8sResource } from '../../types'
import { buildResourceURL, fleetWatch } from '../../api/apiRequests'
import { handleWebsocketEvent } from './utils'
import { useFleetK8sAPIPath } from '../../api/useFleetK8sAPIPath'
import { useIsFleetAvailable } from '../../api/useIsFleetAvailable'

/**
 * Cache for fleet resources.
 * The key is the request path, and the value is the resource data.
 */
const fleetResourceCache: Record<string, any> = {}
/**
 * Cache for fleet WebSockets.
 * The key is a cache key generated by getCacheKey, and the value is the WebSocket instance.
 */
const fleetSocketCache: Record<string, WebSocket> = {}

/**
 * Generates a cache key for a given resource.
 * @param model - The Kubernetes model for the resource.
 * @param cluster - The name of the cluster.
 * @param namespace - The namespace of the resource.
 * @param name - The name of the resource.
 * @returns A unique cache key string.
 */
const getCacheKey = ({
  model,
  cluster,
  namespace,
  name,
}: {
  model: any
  cluster?: string
  namespace?: string
  name?: string
}) => {
  return [cluster, model?.apiVersion, model?.kind, namespace, name].join('|')
}

/**
 * Internal hook for watching Kubernetes resources across clusters.
 *
 * This is the implementation that handles resource watching for both hub and remote clusters.
 * For remote clusters, it fetches data and establishes WebSocket connections for real-time updates.
 * WebSocket connections are cached and pooled to optimize performance across multiple watchers.
 * For hub cluster resources, it falls back to the OpenShift Dynamic Plugin SDK `useK8sWatchResource` hook.
 *
 * @internal This function is not intended for direct use. Use `useFleetK8sWatchResource` instead.
 * @template R - The type of the Kubernetes resource.
 * @param hubClusterName - The name of the hub cluster.
 * @param initResource - The resource to watch. Can be null to disable the watch.
 * @returns A tuple containing the watched resource data, a boolean indicating if the data is loaded, and any error that occurred.
 */
export const useFleetK8sWatchResource = <R extends FleetK8sResourceCommon | FleetK8sResourceCommon[]>(
  hubClusterName: string,
  initResource: FleetWatchK8sResource | null
): WatchK8sResult<R> | [undefined, boolean, any] => {
  const { cluster, ...resource } = initResource ?? {}
  const nullResource = !initResource || !resource?.groupVersionKind

  const { isList, groupVersionKind, namespace, name } = resource ?? {}
  const [model] = useK8sModel(groupVersionKind)
  const [backendAPIPath, backendPathLoaded] = useFleetK8sAPIPath(cluster)
  const isFleetAvailable = useIsFleetAvailable()
  const isRemoteCluster = cluster && cluster !== hubClusterName
  const useFleet = isFleetAvailable && isRemoteCluster

  const noCachedValue = useMemo(() => (isList ? [] : (undefined as unknown)) as R, [isList])

  const requestPath = useMemo(
    () =>
      backendPathLoaded && model
        ? buildResourceURL({
            model,
            ns: namespace,
            name,
            cluster,
            basePath: backendAPIPath as string,
          })
        : '',

    [model, namespace, name, cluster, backendPathLoaded, backendAPIPath]
  )

  const [data, setData] = useState<R>(fleetResourceCache[requestPath] ?? noCachedValue)
  const [loaded, setLoaded] = useState<boolean>(!!fleetResourceCache[requestPath])
  const [error, setError] = useState<any>(undefined)

  useEffect(() => {
    let socket: WebSocket | undefined
    const fetchData = async () => {
      setError(undefined)
      if (!useFleet || nullResource) {
        setData(noCachedValue)
        setLoaded(false)
        return
      }

      if (!backendPathLoaded || fleetResourceCache[requestPath]) {
        return
      }

      try {
        const data = (await consoleFetchJSON(requestPath, 'GET')) as R

        const processedData = (
          isList
            ? (data as { items: K8sResourceCommon[] }).items.map((i) => ({ cluster, ...i }))
            : { cluster, ...(data as K8sResourceCommon) }
        ) as R

        fleetResourceCache[requestPath] = processedData

        const watchQuery: any = {
          ns: namespace,
          cluster,
        }

        if (name) {
          watchQuery.fieldSelector = `metadata.name=${name}`
        }

        if (isList) {
          watchQuery.resourceVersion = (data as { metadata: { resourceVersion?: string } })?.metadata?.resourceVersion
        }

        const socketKey = getCacheKey({ model, cluster, namespace, name })
        const cachedSocket = fleetSocketCache[socketKey]

        if (!cachedSocket || cachedSocket.readyState !== WebSocket.OPEN) {
          socket = fleetWatch(model, watchQuery, backendAPIPath as string)

          fleetSocketCache[socketKey] = socket

          socket.onmessage = (event) => {
            try {
              handleWebsocketEvent(event, requestPath, setData, isList, fleetResourceCache, cluster)
            } catch (e) {
              console.error('Failed to parse WebSocket message', e)
            }
          }

          socket.onclose = () => {
            delete fleetSocketCache[socketKey]
          }
        } else {
          socket = cachedSocket
        }

        setData(processedData)
      } catch (err) {
        setError(err)
      } finally {
        setLoaded(true)
      }
    }
    fetchData()
    // Cleanup function to close the WebSocket if it was created by this effect
    return () => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.close()
      }
    }
  }, [
    cluster,
    isList,
    requestPath,
    name,
    namespace,
    nullResource,
    noCachedValue,
    useFleet,
    backendPathLoaded,
    model,
    backendAPIPath,
  ])

  const [defaultData, defaultLoaded, defaultError] = useK8sWatchResource<R>(useFleet ? null : resource)

  if (nullResource) return [undefined, false, undefined]

  return useFleet
    ? [fleetResourceCache[requestPath] ?? data ?? noCachedValue, fleetResourceCache[requestPath] ? true : loaded, error]
    : [defaultData, defaultLoaded, defaultError]
}

/**
 * Clears the cache for fleet resources and closes any open WebSockets.
 */
export function clearFleetK8sWatchResourceCache() {
  Object.keys(fleetResourceCache).forEach((key) => delete fleetResourceCache[key])
  Object.values(fleetSocketCache).forEach((socket) => {
    if (socket.readyState === WebSocket.OPEN) {
      socket.close()
    }
  })
  Object.keys(fleetSocketCache).forEach((key) => delete fleetSocketCache[key])
}
